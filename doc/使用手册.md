# 日志系统使用手册

> **版本：** 2.0
> **日期：** 2025-12-01
> **项目：** ww_log_refactor

---

## 目录

1. [系统概述](#1-系统概述)
2. [快速开始](#2-快速开始)
3. [核心概念](#3-核心概念)
4. [API 参考](#4-api-参考)
5. [配置指南](#5-配置指南)
6. [使用示例](#6-使用示例)
7. [常见问题](#7-常见问题)
8. [性能优化](#8-性能优化)

---

## 1. 系统概述

### 1.1 设计目标

- **节省空间**：相比传统日志系统，代码空间减少 60-80%，RAM 减少 50%+
- **灵活控制**：支持编译时和运行时的双重过滤机制
- **易于使用**：统一的 API，支持两种模式无缝切换
- **完整追踪**：保留文件名和行号信息，便于问题定位

### 1.2 两种工作模式

| 模式 | 说明 | 优点 | 缺点 | 适用场景 |
|------|------|------|------|----------|
| **String 模式** | 类似 printf 的字符串输出 | 输出直观，易读 | 占用空间大 | 开发调试 |
| **Encode 模式** | 二进制编码输出 | 空间小，RAM少 | 需要解码工具 | 生产环境 |

### 1.3 关键特性

✅ **统一 API**：两种模式使用相同的宏接口
✅ **32个模块**：支持 0-31 共 32 个模块的独立控制
✅ **动态开关**：运行时可以启用/禁用任意模块
✅ **零开销**：被禁用的日志在运行时完全不执行
✅ **参数记录**：Encode 模式支持最多 8 个参数值记录

---

## 2. 快速开始

### 2.1 基本使用（5分钟入门）

#### 步骤 1：包含头文件

```c
#include "ww_log.h"
#include "demo_in.h"  // 如果在模块内部使用
```

#### 步骤 2：初始化（在 main 函数中）

```c
int main(void)
{
    /* 初始化日志系统 */
    ww_log_init();

    /* 可选：配置模块掩码 */
    ww_log_set_module_mask(0xFFFFFFFF);  // 全部启用

    /* 开始使用日志 */
    LOG_INF(WW_LOG_MODULE_DEFAULT, "System started");

    // 你的应用代码...
}
```

#### 步骤 3：在代码中使用

```c
void my_function(int value)
{
    LOG_DBG(WW_LOG_MODULE_DEFAULT, "Function called with value=%d", value);

    if (value < 0) {
        LOG_ERR(WW_LOG_MODULE_DEFAULT, "Invalid value: %d", value);
        return;
    }

    LOG_INF(WW_LOG_MODULE_DEFAULT, "Processing value: %d", value);
}
```

#### 步骤 4：编译并运行

```bash
# String 模式（开发调试）
make MODE=str
./bin/log_test_str

# Encode 模式（生产环境）
make MODE=encode
./bin/log_test_encode

# 解码 Encode 模式的输出
./bin/log_test_encode | python3 tools/log_decoder.py -
```

### 2.2 输出示例

**String 模式输出：**
```
[INF] demo_init.c:21 - Demo module initializing...
[DBG] demo_init.c:26 - Checking hardware...
[ERR] app_main.c:45 - Failed to open file, errno=2
```

**Encode 模式输出：**
```
0x02101A03
0x02101D06 0x00000000
0x06102D02 0x00000002
```

**解码后的输出：**
```
[DBG][DEMO] demo_init.c:26
[INF][DEMO] demo_init.c:29 Params:[0x00000000]
[INF][APP] app_main.c:45 Params:[0x00000002]
```

---

## 3. 核心概念

### 3.1 模块 (Module)

系统支持 32 个模块（ID: 0-31），每个模块可以独立控制启用/禁用。

#### 预定义模块：

```c
#define WW_LOG_MODULE_DEFAULT   0   // 默认/通用模块
#define WW_LOG_MODULE_DEMO      1   // DEMO 模块
#define WW_LOG_MODULE_TEST      2   // TEST 模块
#define WW_LOG_MODULE_APP       3   // APP 模块
#define WW_LOG_MODULE_DRIVERS   4   // DRIVERS 模块
#define WW_LOG_MODULE_BROM      5   // BROM 模块
// 6-31: 预留给未来使用
```

### 3.2 日志级别 (Log Level)

4 个日志级别（2-bit 编码）：

```c
#define WW_LOG_LEVEL_ERR  0  // 错误：系统故障、关键问题
#define WW_LOG_LEVEL_WRN  1  // 警告：潜在问题
#define WW_LOG_LEVEL_INF  2  // 信息：重要状态变化
#define WW_LOG_LEVEL_DBG  3  // 调试：详细执行流程
```

**使用宏：**
```c
LOG_ERR(module_id, fmt, ...)  // 错误级别
LOG_WRN(module_id, fmt, ...)  // 警告级别
LOG_INF(module_id, fmt, ...)  // 信息级别
LOG_DBG(module_id, fmt, ...)  // 调试级别
```

### 3.3 双重过滤机制

#### 编译时过滤（静态）

通过 `WW_LOG_LEVEL_THRESHOLD` 设置全局阈值：

```c
// ww_log_config.h
#define CONFIG_WW_LOG_LEVEL_THRESHOLD   2  // 只保留 ERR, WRN, INF
```

- 低于阈值的日志代码会被完全移除（零开销）
- 编译后的二进制文件中不包含这些日志

#### 运行时过滤（动态）

通过模块掩码控制哪些模块启用：

```c
// 启用所有模块
ww_log_set_module_mask(0xFFFFFFFF);

// 只启用 DEMO 和 DRIVERS
ww_log_set_module_mask((1 << WW_LOG_MODULE_DEMO) |
                       (1 << WW_LOG_MODULE_DRIVERS));

// 禁用 TEST 模块
ww_log_disable_module(WW_LOG_MODULE_TEST);
```

### 3.4 LOG_ID 分配机制（仅 Encode 模式）

**设计：** 每个模块分配 32 个 LOG_ID 槽位

```
模块基地址 = 模块ID × 32
LOG_ID = 模块基地址 + 文件偏移量 (0-31)
```

**示例：**
```
DEMO 模块:
  - 模块ID = 1
  - 基地址 = 1 × 32 = 32
  - demo_init.c   → LOG_ID = 32 + 1 = 33
  - demo_process.c → LOG_ID = 32 + 2 = 34
```

---

## 4. API 参考

### 4.1 日志输出宏

#### `LOG_ERR(module_id, fmt, ...)`
**功能：** 输出错误级别日志
**参数：**
- `module_id`: 模块 ID (0-31)，在 str 模式使用数字，encode 模式使用字符串
- `fmt`: printf 风格的格式字符串
- `...`: 格式化参数（可选）

**示例：**
```c
LOG_ERR(WW_LOG_MODULE_DEFAULT, "Memory allocation failed");
LOG_ERR(WW_LOG_MODULE_DRIVERS, "UART error, code=%d", error_code);
```

#### `LOG_WRN(module_id, fmt, ...)`
**功能：** 输出警告级别日志

#### `LOG_INF(module_id, fmt, ...)`
**功能：** 输出信息级别日志

#### `LOG_DBG(module_id, fmt, ...)`
**功能：** 输出调试级别日志

---

### 4.2 模块控制 API

#### `void ww_log_set_module_mask(U32 mask)`
**功能：** 设置模块掩码，控制哪些模块启用
**参数：**
- `mask`: 32位掩码，每一位控制一个模块 (bit 0 = 模块0, bit 1 = 模块1, ...)

**示例：**
```c
// 全部启用
ww_log_set_module_mask(0xFFFFFFFF);

// 全部禁用
ww_log_set_module_mask(0x00000000);

// 只启用模块 0, 1, 4
ww_log_set_module_mask((1<<0) | (1<<1) | (1<<4));
ww_log_set_module_mask(0x00000013);  // 等价写法
```

#### `U32 ww_log_get_module_mask(void)`
**功能：** 获取当前模块掩码
**返回值：** 当前的 32 位掩码

#### `void ww_log_enable_module(U8 module_id)`
**功能：** 启用单个模块
**参数：**
- `module_id`: 模块 ID (0-31)

**示例：**
```c
ww_log_enable_module(WW_LOG_MODULE_BROM);
```

#### `void ww_log_disable_module(U8 module_id)`
**功能：** 禁用单个模块

#### `U8 ww_log_is_module_enabled(U8 module_id)`
**功能：** 检查模块是否启用
**返回值：** 1=启用, 0=禁用

---

### 4.3 初始化 API

#### `void ww_log_init(void)`
**功能：** 初始化日志系统
**说明：**
- 检测冷启动/热重启（Encode 模式）
- 初始化 RAM 缓冲区（如果启用）
- 打印初始化信息

**使用：** 在 `main()` 函数开始时调用一次

---

### 4.4 RAM 缓冲区 API（仅 Encode 模式）

#### `void ww_log_ram_dump(void)`
**功能：** 转储 RAM 缓冲区中的所有日志

#### `void ww_log_ram_clear(void)`
**功能：** 清空 RAM 缓冲区

#### `U16 ww_log_ram_get_count(void)`
**功能：** 获取缓冲区中的日志条目数

---

## 5. 配置指南

### 5.1 选择工作模式

在 `ww_log_config.h` 或 Makefile 中设置：

```c
// 选项1: String 模式（开发调试）
#define CONFIG_WW_LOG_STR_MODE

// 选项2: Encode 模式（生产环境）
#define CONFIG_WW_LOG_ENCODE_MODE

// 选项3: 禁用日志（发布版本）
#define CONFIG_WW_LOG_DISABLED
```

### 5.2 设置日志级别阈值

```c
// ww_log_config.h
#define CONFIG_WW_LOG_LEVEL_THRESHOLD   3  // 0=ERR, 1=WRN, 2=INF, 3=DBG
```

**推荐配置：**
- 开发环境：`3` (DBG - 所有日志)
- 测试环境：`2` (INF - 排除调试日志)
- 生产环境：`1` (WRN - 只保留警告和错误)

### 5.3 配置 RAM 缓冲区（Encode 模式）

```c
// ww_log_config.h
#define CONFIG_WW_LOG_RAM_BUFFER_EN     1      // 启用 RAM 缓冲
#define CONFIG_WW_LOG_RAM_ENTRY_NUM     128    // 缓冲区大小（U32 条目数）
```

**内存占用计算：**
```
RAM 占用 = CONFIG_WW_LOG_RAM_ENTRY_NUM × 4 字节
示例: 128 × 4 = 512 字节
```

### 5.4 配置输出目标

```c
// ww_log_config.h
#define CONFIG_WW_LOG_OUTPUT_UART       1  // UART 实时输出
#define CONFIG_WW_LOG_OUTPUT_RAM        1  // RAM 缓冲区存储
```

---

## 6. 使用示例

### 6.1 模块内部使用（推荐）

**在模块头文件中配置（如 `demo_in.h`）：**

```c
#define CURRENT_MODULE_BASE   WW_LOG_DIR_DEMO_BASE
#define CURRENT_MODULE_TAG    "[DEMO]"
#define CURRENT_MODULE_ID     WW_LOG_MODULE_DEMO

// 自动适配两种模式
#ifdef WW_LOG_MODE_STR
#define CURRENT_LOG_PARAM     CURRENT_MODULE_ID
#else
#define CURRENT_LOG_PARAM     CURRENT_MODULE_TAG
#endif

// 文件偏移（可选）
#define CURRENT_FILE_OFFSET   DEMO_FILE_INIT  // 1
#define CURRENT_LOG_ID        (CURRENT_MODULE_BASE + CURRENT_FILE_OFFSET)
```

**在源文件中使用：**

```c
#include "demo_in.h"

void demo_init(void)
{
    // 使用 CURRENT_LOG_PARAM 自动适配模式
    LOG_INF(CURRENT_LOG_PARAM, "DEMO module initializing...");
    LOG_DBG(CURRENT_LOG_PARAM, "Checking hardware...");

    int status = check_hardware();
    if (status != 0) {
        LOG_ERR(CURRENT_LOG_PARAM, "Hardware check failed, status=%d", status);
        return;
    }

    LOG_INF(CURRENT_LOG_PARAM, "DEMO init complete");
}
```

### 6.2 直接使用（简单场景）

```c
#include "ww_log.h"

void simple_function(void)
{
    LOG_INF(WW_LOG_MODULE_DEFAULT, "Function started");

    int result = do_something();
    LOG_DBG(WW_LOG_MODULE_DEFAULT, "Result: %d", result);
}
```

### 6.3 动态控制模块开关

```c
void debug_scenario_1(void)
{
    /* 调试场景1: 只看 DRIVERS 模块的日志 */
    U32 saved_mask = ww_log_get_module_mask();

    ww_log_set_module_mask(1 << WW_LOG_MODULE_DRIVERS);

    // 执行测试...
    test_uart();
    test_spi();
    test_i2c();

    // 恢复原来的设置
    ww_log_set_module_mask(saved_mask);
}

void debug_scenario_2(void)
{
    /* 调试场景2: 排除噪音大的 TEST 模块 */
    ww_log_disable_module(WW_LOG_MODULE_TEST);

    // 执行主流程...
    run_application();
}
```

### 6.4 条件日志（进阶）

```c
void performance_critical_function(void)
{
    // 只在 DEBUG 模式下记录详细日志
    #if (WW_LOG_LEVEL_THRESHOLD >= WW_LOG_LEVEL_DBG)
    U32 start_time = get_timestamp();
    #endif

    // 性能关键代码...
    do_fast_operation();

    #if (WW_LOG_LEVEL_THRESHOLD >= WW_LOG_LEVEL_DBG)
    U32 elapsed = get_timestamp() - start_time;
    LOG_DBG(WW_LOG_MODULE_DEFAULT, "Operation took %u us", elapsed);
    #endif
}
```

---

## 7. 常见问题

### Q1: String 模式和 Encode 模式如何选择？

**A:**
- **开发阶段**：使用 String 模式，输出直观，便于调试
- **生产环境**：使用 Encode 模式，节省空间，适合长期运行
- **灵活切换**：代码无需修改，只需重新编译即可切换模式

### Q2: 为什么 String 模式不显示模块名？

**A:**
- 简化输出，减少冗余信息
- 如需模块名，可以自定义宏：
  ```c
  #define DEMO_LOG_INF(fmt, ...) \
      LOG_INF(WW_LOG_MODULE_DEMO, "[DEMO] " fmt, ##__VA_ARGS__)
  ```

### Q3: 如何在不同文件中使用不同的 LOG_ID？

**A:**
在包含模块头文件前定义 `CURRENT_FILE_OFFSET`：

```c
// demo_init.c
#define CURRENT_FILE_OFFSET  1
#include "demo_in.h"
// 此时 CURRENT_LOG_ID = 32 + 1 = 33

// demo_process.c
#define CURRENT_FILE_OFFSET  2
#include "demo_in.h"
// 此时 CURRENT_LOG_ID = 32 + 2 = 34
```

### Q4: 动态开关会影响性能吗？

**A:**
影响极小。检查模块是否启用只是一个位与操作：
```c
if ((g_ww_log_module_mask & (1U << module_id)) != 0) { ... }
```
- 禁用的模块：条件检查失败，后续代码完全不执行（零开销）
- 启用的模块：额外开销仅为一次位运算（纳秒级）

### Q5: 如何解码 Encode 模式的日志？

**A:**
使用提供的 Python 解码工具：

```bash
# 实时解码
./bin/log_test_encode | python3 tools/log_decoder.py -

# 解码文件
python3 tools/log_decoder.py saved_logs.txt

# 过滤特定模块
./bin/log_test_encode | grep "^0x083" | python3 tools/log_decoder.py -
```

### Q6: RAM 缓冲区的作用是什么？

**A:**
- 支持热重启后保留日志（断电前的日志不丢失）
- 便于系统崩溃后分析问题
- 仅在 Encode 模式下可用

---

## 8. 性能优化

### 8.1 编译时优化

**策略1: 提高日志级别阈值**
```c
// 生产环境：只保留错误和警告
#define CONFIG_WW_LOG_LEVEL_THRESHOLD   1  // ERR + WRN
```
- 效果：调试日志的代码完全被移除
- 收益：减少代码空间 40-60%

**策略2: 禁用某些模块的日志**
```c
// 编译时就排除 TEST 模块
#define WW_LOG_MODULE_TEST_ENABLED  0

// 在代码中使用
#if WW_LOG_MODULE_TEST_ENABLED
LOG_DBG(WW_LOG_MODULE_TEST, "Test log");
#endif
```

### 8.2 运行时优化

**策略1: 合理使用模块掩码**
```c
void production_mode(void)
{
    // 生产环境：只启用关键模块
    ww_log_set_module_mask((1 << WW_LOG_MODULE_APP) |
                          (1 << WW_LOG_MODULE_DRIVERS));
}
```

**策略2: 动态调整日志级别**
虽然级别阈值是编译时的，但可以通过模块开关间接控制：
```c
// 调试时临时启用所有模块
void enable_verbose_logging(void) {
    ww_log_set_module_mask(0xFFFFFFFF);
}

// 正常运行时只保留必要模块
void normal_logging(void) {
    ww_log_set_module_mask(0x0000001F);  // 只启用 0-4 号模块
}
```

### 8.3 空间对比

**实测数据（示例）：**

| 配置 | 代码空间 | RAM 占用 |
|------|----------|----------|
| String 模式 (全部日志) | 100% | 100% |
| String 模式 (阈值=INF) | ~70% | ~70% |
| Encode 模式 (全部日志) | ~35% | ~20% |
| Encode 模式 (阈值=WRN) | ~15% | ~10% |

---

## 附录 A: 完整示例程序

```c
/**
 * 完整示例：演示日志系统的主要功能
 */
#include "ww_log.h"

int main(void)
{
    /* ===== 初始化 ===== */
    ww_log_init();

    /* ===== 基本使用 ===== */
    LOG_INF(WW_LOG_MODULE_DEFAULT, "System started");
    LOG_DBG(WW_LOG_MODULE_DEFAULT, "Debug info: version=%d.%d", 2, 0);

    /* ===== 模块控制 ===== */
    // 只启用 APP 和 DRIVERS 模块
    ww_log_set_module_mask((1 << WW_LOG_MODULE_APP) |
                          (1 << WW_LOG_MODULE_DRIVERS));

    LOG_INF(WW_LOG_MODULE_APP, "This will be shown");
    LOG_INF(WW_LOG_MODULE_TEST, "This will be filtered out");

    /* ===== 动态调试 ===== */
    if (need_detailed_logs) {
        ww_log_enable_module(WW_LOG_MODULE_TEST);
    }

    /* ===== 错误处理 ===== */
    int result = do_critical_operation();
    if (result < 0) {
        LOG_ERR(WW_LOG_MODULE_DEFAULT, "Operation failed, code=%d", result);
        return -1;
    }

    LOG_INF(WW_LOG_MODULE_DEFAULT, "System shutdown");
    return 0;
}
```

---

## 附录 B: 文件结构速查

```
include/
├── file_id.h           # LOG_ID 分配（encode 模式）
├── ww_log.h            # 主入口，统一 API
├── ww_log_config.h     # 配置+类型定义
├── ww_log_modules.h    # 模块 ID + 动态开关
├── ww_log_str.h        # String 模式实现
└── ww_log_encode.h     # Encode 模式实现

src/core/
├── ww_log_common.c     # 初始化函数
├── ww_log_modules.c    # 模块开关管理
├── ww_log_str.c        # String 模式输出
└── ww_log_encode.c     # Encode 模式输出

src/<module>/
├── <module>_in.h       # 模块内部头文件（定义 CURRENT_LOG_PARAM）
└── <module>_xxx.c      # 模块源文件

tools/
└── log_decoder.py      # Encode 模式解码工具
```

---

## 附录 C: 宏定义速查表

### 日志输出宏
```c
LOG_ERR(module_id, fmt, ...)  // 错误
LOG_WRN(module_id, fmt, ...)  // 警告
LOG_INF(module_id, fmt, ...)  // 信息
LOG_DBG(module_id, fmt, ...)  // 调试
```

### 模块 ID 常量
```c
WW_LOG_MODULE_DEFAULT   // 0
WW_LOG_MODULE_DEMO      // 1
WW_LOG_MODULE_TEST      // 2
WW_LOG_MODULE_APP       // 3
WW_LOG_MODULE_DRIVERS   // 4
WW_LOG_MODULE_BROM      // 5
```

### 日志级别常量
```c
WW_LOG_LEVEL_ERR  // 0
WW_LOG_LEVEL_WRN  // 1
WW_LOG_LEVEL_INF  // 2
WW_LOG_LEVEL_DBG  // 3
```

---

**文档结束**

如有问题或建议，请参考源码注释或联系开发团队。
