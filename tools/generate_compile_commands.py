#!/usr/bin/env python3
"""
Auto-generate compile commands with injected file IDs

This tool:
1. Parses log_file_id.h to extract file-to-ID mappings
2. Automatically infers module ID from file path
3. Generates compile commands with -D flags injected

Usage:
    python3 tools/generate_compile_commands.py > compile.sh
    chmod +x compile.sh
    ./compile.sh
"""

import re
import sys
from pathlib import Path

# Module inference rules (based on directory structure)
MODULE_INFERENCE_RULES = {
    r'/brom/':     'WW_LOG_MOD_BROM',
    r'/drivers/':  'WW_LOG_MOD_DRIVERS',
    r'/app/':      'WW_LOG_MOD_APP',
    r'/test/':     'WW_LOG_MOD_TEST',
    r'/demo/':     'WW_LOG_MOD_DEMO',
}

def infer_module_id(file_path):
    """Infer module ID from file path"""
    normalized_path = file_path.replace('\\', '/')

    for pattern, module_id in MODULE_INFERENCE_RULES.items():
        if pattern in normalized_path:
            return module_id

    return 'WW_LOG_MOD_APP'  # Default fallback

def parse_log_file_id_header(header_path):
    """
    Parse log_file_id.h to extract file-to-ID mappings

    Expected format:
        FILE_ID_DRV_I2C = 153,  /* src/drivers/drv_i2c.c */

    Or with explicit module annotation:
        FILE_ID_DRV_I2C = 153,  /* src/drivers/drv_i2c.c | WW_LOG_MOD_DRIVERS */

    Returns:
        dict: { 'src/drivers/drv_i2c.c': ('FILE_ID_DRV_I2C', 'WW_LOG_MOD_DRIVERS') }
    """
    mapping = {}

    with open(header_path, 'r', encoding='utf-8') as f:
        content = f.read()

    # Pattern to match:
    # FILE_ID_XXX = NNN,  /* src/path/file.c */
    # or
    # FILE_ID_XXX = NNN,  /* src/path/file.c | MODULE_ID */
    pattern = r'(FILE_ID_\w+)\s*=\s*\d+,\s*/\*\s*([^|*]+?)(?:\s*\|\s*(\w+))?\s*\*/'

    for match in re.finditer(pattern, content):
        file_id = match.group(1)
        file_path = match.group(2).strip()
        explicit_module = match.group(3)

        # Use explicit module ID if provided, otherwise infer from path
        module_id = explicit_module if explicit_module else infer_module_id(file_path)

        mapping[file_path] = (file_id, module_id)

    return mapping

def generate_compile_commands(mapping, cc='gcc', cflags='-Iinclude -O2 -Wall', output_dir='build'):
    """Generate shell script with compile commands"""

    print("#!/bin/bash")
    print("#")
    print("# Auto-generated compile script with injected file IDs")
    print("# Generated by: tools/generate_compile_commands.py")
    print("#")
    print("# DO NOT EDIT MANUALLY - Regenerate using:")
    print("#   python3 tools/generate_compile_commands.py > compile.sh")
    print("#")
    print()
    print("set -e  # Exit on error")
    print()
    print("# Create build directory")
    print(f"mkdir -p {output_dir}")
    print()
    print("# Color output")
    print("GREEN='\\033[0;32m'")
    print("YELLOW='\\033[1;33m'")
    print("NC='\\033[0m' # No Color")
    print()
    print("echo \"${GREEN}=== Compiling with auto-injected file IDs ===${NC}\"")
    print()

    # Generate compile command for each file
    for file_path, (file_id, module_id) in sorted(mapping.items()):
        obj_file = f"{output_dir}/{Path(file_path).stem}.o"

        print(f"echo \"${{YELLOW}}Compiling {file_path}...${{NC}}\"")
        print(f"{cc} -c {file_path} \\")
        print(f"    -D{file_id}={file_id} \\")  # Make enum value available
        print(f"    -DCURRENT_FILE_ID={file_id} \\")
        print(f"    -DCURRENT_MODULE_ID={module_id} \\")
        print(f"    {cflags} \\")
        print(f"    -o {obj_file}")
        print()

    print("echo \"${GREEN}=== Compilation complete ===${NC}\"")

def main():
    import argparse

    parser = argparse.ArgumentParser(
        description='Generate compile commands with auto-injected file IDs',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate compile script
  python3 tools/generate_compile_commands.py > compile.sh
  chmod +x compile.sh
  ./compile.sh

  # Custom header location
  python3 tools/generate_compile_commands.py --header custom/log_file_id.h

  # Custom compiler and flags
  python3 tools/generate_compile_commands.py --cc arm-none-eabi-gcc --cflags "-Iinclude -Os -mcpu=cortex-m4"
        """
    )

    parser.add_argument('--header', default='include/log_file_id.h',
                        help='Path to log_file_id.h (default: include/log_file_id.h)')
    parser.add_argument('--cc', default='gcc',
                        help='C compiler (default: gcc)')
    parser.add_argument('--cflags', default='-Iinclude -O2 -Wall',
                        help='Compiler flags (default: "-Iinclude -O2 -Wall")')
    parser.add_argument('--output-dir', default='build',
                        help='Output directory for .o files (default: build)')

    args = parser.parse_args()

    # Check if header exists
    if not Path(args.header).exists():
        print(f"Error: Header file not found: {args.header}", file=sys.stderr)
        sys.exit(1)

    # Parse header
    mapping = parse_log_file_id_header(args.header)

    if not mapping:
        print(f"Warning: No file ID mappings found in {args.header}", file=sys.stderr)
        print("Make sure your enum comments follow the format:", file=sys.stderr)
        print("  FILE_ID_XXX = 123,  /* src/path/file.c */", file=sys.stderr)
        sys.exit(1)

    # Generate compile commands
    generate_compile_commands(mapping, args.cc, args.cflags, args.output_dir)

    # Print statistics to stderr (won't appear in generated script)
    print(f"# Generated compile commands for {len(mapping)} files", file=sys.stderr)

if __name__ == '__main__':
    main()
